{
  "cells": [
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "---\n",
        "title: \"Manim Gallery\"\n",
        "subtitle: \"A collection of animation previews\" \n",
        "author: \"Corey Voller\"\n",
        "date: \"2025-05-15\"\n",
        "toc: true\n",
        "toc-expand: 3\n",
        "jupyter: python3\n",
        "---\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "# Example Gallery\n",
        "\n",
        "This gallery contains a collection of animations made using manim with video outputs and code. Feel free to copy and paste them into your projects.\n",
        "\n",
        "## Urn Animation\n",
        "\n",
        "<video width=\"640\" controls>\n",
        "\n",
        "<source src=\"videos/DrawUrn.mp4\" type=\"video/mp4\">\n",
        "\n",
        "Your browser does not support the video tag. </video>\n"
      ],
      "id": "c6a961fa"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| echo: true\n",
        "#| eval: false\n",
        "from manim import *\n",
        "\n",
        "class DrawUrn(Scene):\n",
        "    def construct(self):\n",
        "        def color_interpolate(start_color, end_color, alpha):\n",
        "            start_rgb = color_to_rgb(start_color)\n",
        "            end_rgb = color_to_rgb(end_color)\n",
        "            interp_rgb = [(1 - alpha) * s + alpha * e for s, e in zip(start_rgb, end_rgb)]\n",
        "            return rgb_to_color(interp_rgb)\n",
        "        text = Text(\"Urn randomisation in clinical trials\", font_size=32)\n",
        "# Import urn svg\n",
        "        urn = SVGMobject(\"urn.svg\")\n",
        "        urn.set_stroke(color=\"#3B2F2F\", width=3)\n",
        "        urn.set_fill(color=\"#C18F5A\", opacity=1)\n",
        "        urn.scale(2)\n",
        "# Draw outline and fill\n",
        "        text.next_to(urn, DOWN, buff=0.5)\n",
        "        self.play(Write(text),run_time=2)\n",
        "        self.play(DrawBorderThenFill(urn, run_time=4))\n",
        "# Colour light and dark\n",
        "        lighter_color = \"#E6BE8A\"  # Lighter color\n",
        "        darker_color = \"#3B2F2F\"  # Darker color\n",
        "        lighter_indices = [5,6,7,10]\n",
        "        parts = [urn[i] for i in lighter_indices]\n",
        "        anims = [\n",
        "            UpdateFromAlphaFunc(part, lambda m, a: m.set_fill(color_interpolate(\"#C18F5A\", lighter_color, a)))\n",
        "            for part in parts\n",
        "        ]\n",
        "        dark_parts = [urn[i] for i in range(1, 5)]\n",
        "        dark_anims = [\n",
        "            UpdateFromAlphaFunc(part, lambda m, a: m.set_fill(color_interpolate(\"#C18F5A\", darker_color, a)))\n",
        "            for part in dark_parts\n",
        "        ]\n",
        "        self.play(*anims,*dark_anims, run_time=1)\n",
        "        lid_parts = VGroup(urn[8], urn[10])\n",
        "        rest_of_urn = VGroup(*[urn[i] for i in range(1, len(urn))])\n",
        "        self.add(rest_of_urn, lid_parts)\n",
        "# Move lid\n",
        "# Move urn and scale\n",
        "        new_text = Tex(\"Urn algorithm: \", font_size=32)\n",
        "        ul = Underline(new_text)\n",
        "        ul_text = VGroup(ul,new_text)\n",
        "        ul_text.shift(UP*2 + RIGHT*2)\n",
        "        self.play(urn.animate.scale(0.7).shift(LEFT * 4),\n",
        "                  lid_parts.animate.scale(0.7).shift(UP * 1 + LEFT * 4).rotate(PI / 8),\n",
        "                  Transform(text,ul_text),\n",
        "                  run_time=2)\n",
        "        self.wait(1)\n",
        "        draw_text = \"Draw a ball with replacement\"\n",
        "        # Define alpha + ball groups\n",
        "        def make_alpha_ball(color):\n",
        "            alpha = MathTex(r\"\\alpha\")\n",
        "            ball = Circle(radius=0.1, color=color, fill_opacity=1)\n",
        "            ball.next_to(alpha, RIGHT, buff=0.2)\n",
        "            return VGroup(alpha, ball), ball\n",
        "\n",
        "        group_white, white_ball = make_alpha_ball(WHITE)\n",
        "        group_red, red_ball = make_alpha_ball(RED)\n",
        "\n",
        "        both_groups = VGroup(group_white, group_red).arrange(DOWN, aligned_edge=LEFT)\n",
        "        both_groups.next_to(ul_text, DOWN, buff=1)\n",
        "\n",
        "        self.play(Write(group_white[0]), GrowFromCenter(white_ball))\n",
        "        self.wait(0.3)\n",
        "        self.play(Write(group_red[0]), GrowFromCenter(red_ball))\n",
        "        self.wait(0.5)\n",
        "\n",
        "        # Move balls to starting point above scene\n",
        "        white_anim = white_ball.copy()\n",
        "        red_anim  = red_ball.copy()\n",
        "\n",
        "        self.add(white_anim, red_anim )\n",
        "        urn_front = urn[1]\n",
        "        # Define final inside positions (center of urn)\n",
        "        white_final = white_ball.copy().move_to(urn_front.get_center() + LEFT * 0.2 + DOWN * 1.2)\n",
        "        red_final = red_ball.copy().move_to(urn_front.get_center() + RIGHT * 0.2 + DOWN * 1.5)\n",
        "        white_final.set_z_index(-2)\n",
        "        red_final.set_z_index(-2)\n",
        "        white_final.set_opacity(1)\n",
        "        red_final.set_opacity(1)\n",
        "\n",
        "        # Create arcing paths\n",
        "        white_path = CubicBezier(\n",
        "            white_anim.get_center(),\n",
        "            white_anim.get_center() + UP*2 + LEFT*1.3,\n",
        "            urn_front.get_top() + UP + LEFT*0.8,\n",
        "            urn_front.get_top() + DOWN * 1.5,\n",
        "        )\n",
        "\n",
        "        red_path = CubicBezier(\n",
        "            red_anim.get_center(),\n",
        "            red_anim.get_center() + UL * 2,\n",
        "            urn_front.get_top() + UP + LEFT,\n",
        "            urn_front.get_top() + DOWN * 1.5,\n",
        "        )\n",
        "\n",
        "        # Animate white ball\n",
        "        self.play(MoveAlongPath(white_anim, white_path, run_time=1.8))\n",
        "        self.play(white_anim.animate.scale(0.5), FadeOut(white_anim, shift=DOWN*0.2), FadeIn(white_final))\n",
        "        self.wait(0.2)\n",
        "\n",
        "        # Animate red ball\n",
        "        self.play(MoveAlongPath(red_anim, red_path, run_time=1.8))\n",
        "        self.play(red_anim.animate.scale(0.5), FadeOut(red_anim, shift=DOWN*0.2), FadeIn(red_final))\n",
        "        self.wait(0.2)\n",
        "\n",
        "        # Make urn transparent to reveal inside\n",
        "        self.play(urn.animate.set_fill(opacity=0.3))\n",
        "        # Add treatment labels\n",
        "        label_white = Text(\"Treatment A\", font_size=24).next_to(group_white, UP, buff=0.3)\n",
        "        label_red = Text(\"Treatment B\", font_size=24).next_to(group_red, UP, buff=0.3)\n",
        "\n",
        "        # Group each alpha+ball with its label\n",
        "        pair_white = VGroup(label_white, group_white)\n",
        "        pair_red = VGroup(label_red, group_red)\n",
        "        #side_side = VGroup(pair_white, pair_red)\n",
        "       \n",
        "        # Add to scene\n",
        "        #self.play(side_side.animate.arrange(RIGHT, buff=1,center=True))\n",
        "\n",
        "        # Animate down smoothly into position below ul_text\n",
        "        self.play(\n",
        "           pair_white.animate.move_to(ul_text.get_center() + DOWN*1.5 + LEFT * 1.5),\n",
        "           pair_red.animate.move_to(ul_text.get_center() + DOWN*1.5 + RIGHT * 1.5),\n",
        "            run_time=2,\n",
        "            rate_func=smooth\n",
        "        )\n",
        "        #self.play(side_side.move_to(ul_text.get_center() + DOWN * 1.5))\n",
        "        self.play(\n",
        "            group_white.animate.move_to(pair_white[1].get_center()+LEFT*4),\n",
        "            group_red.animate.move_to(pair_red[1].get_center()+LEFT*4),\n",
        "            FadeOut(group_white[0]),\n",
        "            FadeOut(group_red[0]),\n",
        "            group_white[1].animate.move_to(pair_white[0].get_left()+LEFT*0.5),\n",
        "            group_red[1].animate.move_to(pair_red[0].get_left()+LEFT*0.5),\n",
        "\n",
        "          #  FadeIn(label_white, shift=UP * 0.3),\n",
        "          #  FadeIn(label_red, shift=UP * 0.3),\n",
        "            run_time=2,\n",
        "            rate_func=smooth\n",
        "        )\n",
        "        self.wait(1)\n",
        "        # Simulate drawing white ball\n",
        "        start = white_final.get_center()\n",
        "        control = start + UP * 2 + LEFT * 0.7\n",
        "        end = pair_white.get_bottom() + DOWN * 0.5\n",
        "\n",
        "# Quadratic Bezier â‰ˆ Cubic Bezier with repeated control point\n",
        "        arc_path = CubicBezier(start, control, control, end)\n",
        "        # Copy the ball to animate (keep the original inside the urn)\n",
        "        picked_ball = white_final.copy()\n",
        "        picked_ball.set_z_index(5)\n",
        "        self.add(picked_ball)\n",
        "\n",
        "# Animate the ball moving along the arc\n",
        "        self.play(MoveAlongPath(picked_ball, arc_path), run_time=2)\n",
        "\n",
        "# Optionally, fade the picked ball into the final position (or keep it there)\n",
        "        self.play(picked_ball.animate.move_to(end), run_time=0.3)\n",
        "        def make_beta_ball(color):\n",
        "            beta = MathTex(r\"\\beta\")\n",
        "            ball = Circle(radius=0.1, color=color, fill_opacity=1)\n",
        "            ball.next_to(beta, RIGHT, buff=0.2)\n",
        "            return VGroup(beta, ball)\n",
        "\n",
        "        group_red2 = make_beta_ball(RED)\n",
        "        group_red2.arrange(DOWN, aligned_edge=LEFT)\n",
        "        group_red2.next_to(ul_text, DOWN*2, buff=1)\n",
        "\n",
        "        self.play(Write(group_red2[0]), GrowFromCenter(group_red2[1]))\n",
        "        self.wait(0.3)\n",
        "\n",
        "# Path from current group position to urn\n",
        "        start = group_red2.get_center()\n",
        "        end = urn_front.get_center() + RIGHT * 0.1 + DOWN * 1.7\n",
        "\n",
        "        red_path = CubicBezier(\n",
        "            start,\n",
        "            start + UL * 3,\n",
        "            urn_front.get_top() + UP*1.1 + LEFT*1.1,\n",
        "           end\n",
        "        )\n",
        "\n",
        "# Move the whole group\n",
        "        self.play(MoveAlongPath(group_red2, red_path, run_time=1.8))\n",
        "        self.wait(2)\n",
        "        self.play(FadeOut(group_red2))\n",
        "        self.play(urn.animate.set_fill(opacity=1))\n",
        "        self.wait(2)"
      ],
      "id": "7321f490",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "## Simple Randomisation\n",
        "\n",
        "<video width=\"640\" controls>\n",
        "\n",
        "<source src=\"videos/SimpleRandomisation.mp4\" type=\"video/mp4\">\n",
        "\n",
        "Your browser does not support the video tag. </video>\n"
      ],
      "id": "422e43df"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| echo: true\n",
        "#| eval: false\n",
        "from manim import *\n",
        "import random\n",
        "\n",
        "class SimpleRandomisation(MovingCameraScene):\n",
        "    def construct(self):\n",
        "        def make_group_box(label_text, x_shift, color):\n",
        "            label = Text(label_text, color=color).to_edge(UP).shift(RIGHT * x_shift)\n",
        "            slots = VGroup()\n",
        "            for i in range(N):\n",
        "                row, col = divmod(i, cols)\n",
        "                circle = Circle(radius=radius, color=WHITE).set_fill(GREY, opacity=0.2)\n",
        "                circle.move_to([x_shift + col * 0.8 - 2, 2 - row * 0.8, 0])\n",
        "                slots.add(circle)\n",
        "            box = SurroundingRectangle(slots, buff=0.5)\n",
        "            return label, slots, box\n",
        "\n",
        "        N = 10\n",
        "        cols = 5\n",
        "        radius = 0.3\n",
        "\n",
        "        # Treatment and Control Groups (First Box)\n",
        "        treat_label, treat_slots, treat_box = make_group_box(\"Treatment\", -3.5, RED)\n",
        "        ctrl_label, ctrl_slots, ctrl_box = make_group_box(\"Control\", 3.5, BLUE)\n",
        "\n",
        "        group1 = VGroup(treat_label, ctrl_label, treat_slots, ctrl_slots, treat_box, ctrl_box)\n",
        "        sample_text1 = Text(f\"Sample size: {N}\", font_size=30).next_to(group1, DOWN)\n",
        "        self.add(group1, sample_text1)\n",
        "\n",
        "        # Participants\n",
        "        balls = VGroup()\n",
        "        for i in range(N):\n",
        "            ball = Circle(radius=radius,color=WHITE).set_fill(GREY).move_to([i * 0.6 - (N * 0.6) / 2, -3.5, 0])\n",
        "            balls.add(ball)\n",
        "        self.add(balls)\n",
        "\n",
        "        # Randomisation\n",
        "        treat_i = ctrl_i = 0\n",
        "        for i in range(N):\n",
        "            choice = random.choice([\"treatment\", \"control\"])\n",
        "            ball = balls[i]\n",
        "            if choice == \"treatment\":\n",
        "                target = treat_slots[treat_i]\n",
        "                color = RED\n",
        "                treat_i += 1\n",
        "            else:\n",
        "                target = ctrl_slots[ctrl_i]\n",
        "                color = BLUE\n",
        "                ctrl_i += 1\n",
        "            self.play(ball.animate.set_fill(color).move_to(target.get_center()), run_time=0.4)\n",
        "            self.play(target.animate.set_fill(color, opacity=1), run_time=0.3)\n",
        "\n",
        "        self.wait(0.5)\n",
        "\n",
        "        # Camera pans out and moves to new box with n = 20\n",
        "        group2_origin = DOWN * 15\n",
        "        new_N = 20\n",
        "        new_cols = 5\n",
        "        new_radius = 0.3\n",
        "\n",
        "        def make_secondary_box(label_text, x_shift, color):\n",
        "            label = Text(label_text, color=color).move_to(group2_origin + UP * 2.2 + RIGHT * x_shift)\n",
        "            slots = VGroup()\n",
        "            for i in range(new_N):\n",
        "                row, col = divmod(i, new_cols)\n",
        "                circle = Circle(radius=new_radius, color=WHITE).set_fill(GREY, opacity=0.2)\n",
        "                circle.move_to(group2_origin + [x_shift + col * 0.8 - 2, 1 - row * 0.8, 0])\n",
        "                slots.add(circle)\n",
        "            box = SurroundingRectangle(slots, buff=0.5)\n",
        "            return label, slots, box\n",
        "\n",
        "        new_treat_label, new_treat_slots, new_treat_box = make_secondary_box(\"Treatment\", -3.5, RED)\n",
        "        new_ctrl_label, new_ctrl_slots, new_ctrl_box = make_secondary_box(\"Control\", 3.5, BLUE)\n",
        "        group2 = VGroup(new_treat_label, new_ctrl_label, new_treat_slots, new_ctrl_slots, new_treat_box, new_ctrl_box)\n",
        "        sample_text2 = Text(f\"Sample size: {new_N}\", font_size=30).next_to(group2, DOWN)\n",
        "\n",
        "        # Camera zoom and pan\n",
        "        self.add(group2, sample_text2)\n",
        "        self.play(self.camera.frame.animate.move_to(group2_origin).scale(1.5), run_time=2)\n",
        "       \n",
        "\n",
        "        # Animate randomisation again\n",
        "        balls2 = VGroup()\n",
        "        for i in range(new_N):\n",
        "            ball = Circle(radius=new_radius,color=WHITE).set_fill(GREY).move_to(group2_origin + [i * 0.6 - (new_N * 0.6) / 2, -3.5, 0])\n",
        "            balls2.add(ball)\n",
        "        self.add(balls2)\n",
        "\n",
        "        treat_i = ctrl_i = 0\n",
        "        for i in range(new_N):\n",
        "            choice = random.choice([\"treatment\", \"control\"])\n",
        "            ball = balls2[i]\n",
        "            if choice == \"treatment\":\n",
        "                target = new_treat_slots[treat_i]\n",
        "                color = RED\n",
        "                treat_i += 1\n",
        "            else:\n",
        "                target = new_ctrl_slots[ctrl_i]\n",
        "                color = BLUE\n",
        "                ctrl_i += 1\n",
        "            self.play(ball.animate.set_fill(color).move_to(target.get_center()), run_time=0.4)\n",
        "            self.play(target.animate.set_fill(color, opacity=1), run_time=0.3)\n",
        "\n",
        "        self.wait()"
      ],
      "id": "9817c657",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "## Group sequential boundary\n",
        "\n",
        "<video width=\"640\" controls>\n",
        "\n",
        "<source src=\"videos/BoundaryAnimation.mp4\" type=\"video/mp4\">\n",
        "\n",
        "Your browser does not support the video tag. </video>\n"
      ],
      "id": "d340c1a9"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| echo: true\n",
        "#| eval: false\n",
        "from manim import *\n",
        "import numpy as np\n",
        "\n",
        "\n",
        "class BoundaryAnimation(Scene):\n",
        "    def construct(self):\n",
        "        # Define k values and boundaries (boundaries start at k=1)\n",
        "        k_values = np.array([0, 1, 2, 3, 4, 5])\n",
        "        a_crit = np.array([-1.61511306, -0.07126633, 0.81610852, 1.46393433, 1.986610])  # No k=0 boundary\n",
        "        b_crit = np.array([4.442196, 3.141107, 2.564703, 2.221098, 1.986610])  # No k=0 boundary\n",
        "\n",
        "        # Observed paths (starting from k=0, y=0)\n",
        "        observed_red_cross = np.array([0, 1.5, 2.3, 2.7, 4.5])  # Crosses upper boundary\n",
        "        observed_green_cross = np.array([0, -1.2, -1.8, -2.2, -2.5])  # Crosses lower boundary\n",
        "        observed_no_cross = np.array([0,1.8, 1, 1.5, 1.8, 2.1])  # Stays within bounds\n",
        "\n",
        "        # Create axes\n",
        "        axes = Axes(\n",
        "            x_range=[0, 6, 1],\n",
        "            y_range=[-3, 5, 1],\n",
        "            axis_config={\"color\": WHITE},\n",
        "            x_axis_config={\n",
        "                \"numbers_to_include\": [1, 2, 3, 4, 5],  # Only show ticks for x values from 1 to 5\n",
        "            }\n",
        "        )\n",
        "        x_label = Tex(\"Analysis (k)\").next_to(axes.x_axis, DOWN, buff=0.5)\n",
        "        y_label = MathTex(\"Z_k\").next_to(axes.y_axis, LEFT, buff=0.1)\n",
        "        \n",
        "        self.play(Create(axes), Write(x_label), Write(y_label))\n",
        "\n",
        "        # Plot boundaries (starting at k=1)\n",
        "        a_crit_line = axes.plot_line_graph(\n",
        "            x_values=k_values[1:], y_values=a_crit, add_vertex_dots=False, line_color=GREEN, stroke_width=4\n",
        "        )\n",
        "        b_crit_line = axes.plot_line_graph(\n",
        "            x_values=k_values[1:], y_values=b_crit, add_vertex_dots=False, line_color=RED, stroke_width=4\n",
        "        )\n",
        "        self.play(Create(a_crit_line), Create(b_crit_line))\n",
        "        # Labels on graph\n",
        "        reject_text = MathTex(r\"\\text{Reject } H_0\", font_size=24)\n",
        "        reject_text.move_to(axes.c2p(3, b_crit[2]) + UP * 0.5)\n",
        "        self.play(Write(reject_text))\n",
        "\n",
        "        accept_text = MathTex(r\"\\text{Accept } H_0\", font_size=24)\n",
        "        accept_text.move_to(axes.c2p(3, a_crit[2]) + DOWN * 0.4)\n",
        "        self.play(Write(accept_text))\n",
        "\n",
        "        # Function to animate each scenario\n",
        "        def animate_path(observed_values):\n",
        "            observed_dot = Dot(axes.c2p(k_values[0], observed_values[0]), color=BLUE)\n",
        "            self.add(observed_dot)\n",
        "\n",
        "            prev_point = axes.c2p(k_values[0], observed_values[0])\n",
        "            line_segments = []\n",
        "            for i in range(1, len(k_values)):\n",
        "                target_point = axes.c2p(k_values[i], observed_values[i])\n",
        "                new_line = Line(prev_point, target_point, color=BLUE)\n",
        "                line_segments.append(new_line)\n",
        "\n",
        "                self.play(observed_dot.animate.move_to(target_point), Create(new_line), run_time=1)\n",
        "\n",
        "                # Check only for k >= 1 (boundaries start at k=1)\n",
        "                if i >= 1:\n",
        "                    print(f\"k = {k_values[i]}, observed = {observed_values[i]}, a_crit = {a_crit[i-1]}, b_crit = {b_crit[i-1]}\")\n",
        "\n",
        "                    if observed_values[i] > b_crit[i-1]:  # Crossed upper boundary\n",
        "                        new_line.set_color(RED)\n",
        "                        self.play(observed_dot.animate.set_color(RED), new_line.animate.set_color(RED), run_time=0.5)\n",
        "                        break\n",
        "                    elif observed_values[i] < a_crit[i-1]:  # Crossed lower boundary\n",
        "                        new_line.set_color(GREEN)\n",
        "                        self.play(observed_dot.animate.set_color(GREEN), new_line.animate.set_color(GREEN), run_time=0.5)\n",
        "                        break\n",
        "\n",
        "                prev_point = target_point\n",
        "\n",
        "            self.wait(1)\n",
        "            self.play(*[FadeOut(obj) for obj in line_segments], FadeOut(observed_dot))\n",
        "\n",
        "        # Run all three scenarios separately\n",
        "        animate_path(observed_red_cross)  # Scenario 1: Turns red\n",
        "        animate_path(observed_green_cross)  # Scenario 2: Turns green\n",
        "        animate_path(observed_no_cross)  # Scenario 3: Stays blue\n",
        "\n",
        "        self.wait(2)\n"
      ],
      "id": "2cc7be3f",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "## Multi-Arm Multi-Stage (MAMS)\n",
        "\n",
        "<video width=\"640\" controls>\n",
        "\n",
        "<source src=\"videos/MAMS.mp4\" type=\"video/mp4\">\n",
        "\n",
        "Your browser does not support the video tag. </video>\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "## 3 + 3 Dose escalation\n",
        "\n",
        "<video width=\"640\" controls>\n",
        "\n",
        "<source src=\"videos/ThreePlusThree.mp4\" type=\"video/mp4\">\n",
        "\n",
        "Your browser does not support the video tag. </video>\n"
      ],
      "id": "ea196e7b"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| echo: true\n",
        "#| eval: false\n",
        "from manim import *\n",
        "\n",
        "class ThreePlusThree(Scene):\n",
        "    def construct(self):\n",
        "# Create axes\n",
        "        axes = Axes(\n",
        "            x_range=[0, 7, 1],\n",
        "            y_range=[0, 5, 1],\n",
        "            axis_config={\"color\": WHITE},\n",
        "            x_axis_config={\n",
        "                \"numbers_to_include\": [1, 2, 3, 4, 5],  # Only show ticks for x values from 1 to 5\n",
        "            }\n",
        "        )\n",
        "        labels = axes.get_axis_labels(\n",
        "            Tex(\"Time\").scale(0.9), Text(\"Dose\").scale(0.8)\n",
        "        )\n",
        "        self.play(Create(axes), Write(labels),run_time=1.5)\n",
        "        self.wait(1)\n",
        "# Define the function to add a blue arrow between cohorts\n",
        "        def add_cohort_arrow(cohort_dots, y=0.2, color=BLUE, run_time=0.5):\n",
        "            first_dot = cohort_dots[0]\n",
        "            last_dot = cohort_dots[-1]\n",
        "            start_point = first_dot.get_x()\n",
        "            end_point = last_dot.get_x()\n",
        "            arrow = Arrow(\n",
        "                start=axes.c2p(start_point, y),\n",
        "                end=axes.c2p(end_point, y),\n",
        "                buff=0,\n",
        "                stroke_width=6,\n",
        "                tip_length=0.15,\n",
        "                color=color\n",
        "            )\n",
        "            self.play(GrowArrow(arrow), run_time=run_time)\n",
        "            self.wait(0.5)\n",
        "# Draw legend\n",
        "        # Green Dot\n",
        "        non_dlt_dot = Dot(color=GREEN, radius=0.15)\n",
        "        non_dlt_label = Text(\"Non-DLT\").scale(0.6).next_to(non_dlt_dot, RIGHT, buff=0.1)\n",
        "        # Red dot\n",
        "        red_dot = Dot(color=RED, radius=0.15)\n",
        "        dlt_label = Text(\"DLT\").scale(0.6).next_to(red_dot, RIGHT, buff=0.1)\n",
        "        # Dose escalation arrow\n",
        "        up_arrow =  Arrow(\n",
        "            start=ORIGIN,\n",
        "            end=UP * 0.4,\n",
        "            buff=0,\n",
        "            stroke_width=5,     \n",
        "            tip_length=0.15         \n",
        "        )   \n",
        "        esc_label = Text(\"Dose escalation\").scale(0.6).next_to(up_arrow, RIGHT, buff=0.1)\n",
        "        # Patient cohort\n",
        "        cohort_square = Square(\n",
        "            side_length=0.3,\n",
        "            stroke_color=RED,\n",
        "            stroke_width=4,\n",
        "            fill_opacity=0\n",
        "        )\n",
        "        cohort_label = Text(\"Patient cohort\").scale(0.6).next_to(cohort_square, RIGHT, buff=0.1)\n",
        "        # Stack them vertically\n",
        "        legend = VGroup(\n",
        "            VGroup(non_dlt_dot, non_dlt_label),\n",
        "            VGroup(red_dot, dlt_label),\n",
        "            VGroup(up_arrow, esc_label),\n",
        "            VGroup(cohort_square, cohort_label),\n",
        "        ).arrange(DOWN, aligned_edge=LEFT, buff=0.2)\n",
        "        legend.to_corner(UR, buff=0.5)\n",
        "        for item in legend:\n",
        "            self.play(FadeIn(item), run_time=0.5)\n",
        "            self.wait(0.3)\n",
        "        self.wait(3)\n",
        "\n",
        "# Draw first dose\n",
        "        positions = [0.25, 0.5, 0.75]\n",
        "        dots = VGroup()\n",
        "        for x in positions:\n",
        "            # c2p(x, y) converts (x,y) in data coords -> scene coords\n",
        "            dot = Dot(\n",
        "                point=axes.c2p(x, 0.5),\n",
        "                radius=0.20, \n",
        "                color=GREEN)\n",
        "            self.play(FadeIn(dot), run_time=0.5)\n",
        "            self.wait(0.5)\n",
        "            dots.add(dot)\n",
        "        box = SurroundingRectangle(\n",
        "            dots,\n",
        "            color=RED,\n",
        "            stroke_width=4,\n",
        "            buff=0.15  # space between dots and rectangle edge\n",
        "        )\n",
        "        self.play(Create(box), run_time=1)\n",
        "        self.wait(2)\n",
        "        # --- Up arrow above the third dot ---\n",
        "        third_dot = dots[2]\n",
        "        arrow = Arrow(\n",
        "            start=third_dot.get_top() + UP * 0.05,\n",
        "            end=third_dot.get_top() + UP * 1,\n",
        "            buff=0,\n",
        "            stroke_width=4,\n",
        "            tip_length=0.15,\n",
        "            color=YELLOW\n",
        "        )\n",
        "        self.play(GrowArrow(arrow), run_time=0.7)\n",
        "        self.wait(0.5)\n",
        "\n",
        "# Second cohort\n",
        "        new_positions = [1.25, 1.5, 1.75]\n",
        "        second_dots = VGroup()\n",
        "        for x in new_positions:\n",
        "            dot = Dot(point=axes.c2p(x, 1.5), radius=0.20, color=GREEN)\n",
        "            self.play(FadeIn(dot), run_time=0.5)\n",
        "            self.wait(0.2)\n",
        "            second_dots.add(dot)\n",
        "        second_box = SurroundingRectangle(second_dots, color=RED, stroke_width=4, buff=0.15)\n",
        "        self.play(Create(second_box), run_time=1)\n",
        "        # --- Up arrow above the third dot ---\n",
        "        third_dot = second_dots[2]\n",
        "        arrow = Arrow(\n",
        "            start=third_dot.get_top() + UP * 0.05,\n",
        "            end=third_dot.get_top() + UP * 1,\n",
        "            buff=0,\n",
        "            stroke_width=4,\n",
        "            tip_length=0.15,\n",
        "            color=YELLOW\n",
        "        )\n",
        "        self.play(GrowArrow(arrow), run_time=0.7)\n",
        "        self.wait(0.5)\n",
        "# Third cohort at y=2.5 between x=2 and x=3\n",
        "        third_positions = [2.25, 2.5, 2.75]\n",
        "        third_dots = VGroup()\n",
        "        colors = [GREEN, GREEN, RED]  # Third dot is red\n",
        "\n",
        "        for x, color in zip(third_positions, colors):\n",
        "            dot = Dot(point=axes.c2p(x, 2.5), radius=0.20, color=color)\n",
        "            self.play(FadeIn(dot), run_time=0.5)\n",
        "            self.wait(0.2)\n",
        "            third_dots.add(dot)\n",
        "        third_box = SurroundingRectangle(third_dots, color=RED, stroke_width=4, buff=0.15)\n",
        "        self.play(Create(third_box), run_time=1)\n",
        "        self.wait(1.5)\n",
        "        plus = Text(\"+\").scale(1.2)\n",
        "        plus.next_to(third_dots[-1], RIGHT, buff=0.3)\n",
        "        self.play(Write(plus), run_time=0.5)\n",
        "        self.wait(0.5)\n",
        "\n",
        "# Fourth cohort at y=3.5 between x=3 and x=4\n",
        "        fourth_positions = [3.55, 3.80, 4.05]\n",
        "        fourth_dots = VGroup()\n",
        "        colors = [GREEN, GREEN, GREEN] \n",
        "        for x, color in zip(fourth_positions, colors):\n",
        "            dot = Dot(point=axes.c2p(x, 2.5), radius=0.20, color=color)\n",
        "            self.play(FadeIn(dot), run_time=0.5)\n",
        "            self.wait(0.2)\n",
        "            fourth_dots.add(dot)\n",
        "        fourth_box = SurroundingRectangle(fourth_dots, color=RED, stroke_width=4, buff=0.15)\n",
        "        dashed_box = DashedVMobject(fourth_box, num_dashes=20)\n",
        "        self.play(Create(dashed_box), run_time=1)\n",
        "        self.wait(0.5)\n",
        "        # --- Up arrow above the third dot ---\n",
        "        fourth_dot = fourth_dots[2]\n",
        "        arrow = Arrow(\n",
        "            start=fourth_dot.get_top() + UP * 0.05,\n",
        "            end=fourth_dot.get_top() + UP * 1,\n",
        "            buff=0,\n",
        "            stroke_width=4,\n",
        "            tip_length=0.15,\n",
        "            color=YELLOW\n",
        "        )\n",
        "        self.play(GrowArrow(arrow), run_time=0.7)\n",
        "# Fifth Cohort\n",
        "        fifth_positions = [4.35, 4.6, 4.85]\n",
        "        fifth_dots = VGroup()\n",
        "        colors = [GREEN, RED, RED] # Two red\n",
        "        for x, color in zip(fifth_positions, colors):\n",
        "            dot = Dot(point=axes.c2p(x, 3.5), radius=0.20, color=color)\n",
        "            self.play(FadeIn(dot), run_time=0.5)\n",
        "            self.wait(0.2)\n",
        "            fifth_dots.add(dot)\n",
        "        fifth_box = SurroundingRectangle(fifth_dots, color=RED, stroke_width=4, buff=0.15)\n",
        "        self.play(Create(fifth_box), run_time=1)\n",
        "        self.wait(0.5)\n",
        "# End\n",
        "        self.wait(1.5)"
      ],
      "id": "b6275d77",
      "execution_count": null,
      "outputs": []
    }
  ],
  "metadata": {
    "kernelspec": {
      "name": "python3",
      "language": "python",
      "display_name": "Python 3 (ipykernel)",
      "path": "C:\\Users\\Corey\\AppData\\Local\\r-miniconda\\envs\\r-reticulate\\share\\jupyter\\kernels\\python3"
    }
  },
  "nbformat": 4,
  "nbformat_minor": 5
}