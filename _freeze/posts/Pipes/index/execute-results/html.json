{
  "hash": "cdcdef8e697ded3ae30359c12d1c618c",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"More than just a pipe dream\"\nsubtitle: \"The use of different pipes in R\"\nauthor: \"Corey Voller\"\ndate: \"2024-02-11\"\ndate-modified: last-modified\ncategories: [R, code]\nimage: \"pipes.png\"\nbibliography: references.bib\ntoc: true\ntoc-expand: 3\n---\n\n::: {.cell}\n\n:::\n\n\n\n\n# Introduction\n\nNamed after a famous artist Rene Magritte, who painted the famous 'ceci n'est pas une pipe' image, the `magrittr` / `dplyr` packages contains a suite of functions using pipes for data manipulation.\n\nI had a friend at university who frequently bought pipe tobacco as apparently it is much cheaper than regular tobacco. Anyway, much like his smoking habit, `dplyr` can chain things together. In addition to this, it is relatively readable and interpretable in comparison to `data.table` (or at least to me). That isn't to say I don't like `data.table`, it has its place and advantages with larger data sets but I do not often work with such data sets that the efficiency gain outweighs the trade-off between readability. It is important to balance such things and to consider QC'ers or the possibility of someone taking over a piece of code from you.\n\n# R pipe (\\|\\>)\n\nThe native pipe was introduced in R 4.1.0 and acts similarly to the forward pipe (`%>%`) in `magrittr`. Both pipes take in what is on the left-hand side and apply the function on the right-hand side. A number of pipes can be applied sequentially to give a chain of events.\n\n## Native vs Magrittr\n\nThere are some subtle differences between the native and `magrittr` pipe, including operational efficiency/speed, bracket usage, placeholder syntax, etc. For example, using `rlang` we can see what is happening under the hood between the two pipes. I.e.,\n\nThe R native pipe:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrlang::expr(x |> f())\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nf(x)\n```\n\n\n:::\n:::\n\n\n\n\nMagrittr forward pipe:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrlang::expr(x %>% f())\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nx %>% f()\n```\n\n\n:::\n:::\n\n\n\n\nWe can see that the native pipe is changing the structure (evaluating the expression as syntax) whereas the `magrittr` pipe is evaluated as a function call and thus is slightly slower.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmicrobenchmark::microbenchmark(\"sqrt(4)\" = sqrt(4),\n                               \"Native\" = 4 |> sqrt(),\n                               \"Magrittr\" = 4 %>% sqrt())\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nUnit: nanoseconds\n     expr  min   lq mean median   uq   max neval\n  sqrt(4)    0    0   40      0  100   300   100\n   Native    0    0  102      0  100  7300   100\n Magrittr 1600 1700 1943   1700 1800 11900   100\n```\n\n\n:::\n:::\n\n\n\n\nThere is a wonderful answer [here](https://stackoverflow.com/questions/67633022/what-are-the-differences-between-rs-native-pipe-and-the-magrittr-pipe) which goes through in more detail some of the differences.\n\nGenerally speaking though, if you're *really* concerned about speed you wouldn't use `dplyr`.\n\n# Alternative pipes\n\n## Magrittr\n\n### Forward pipe (%\\>%)\n\nAs briefly mentioned, the forward pipe from `magrittr` behaves similarly to the native pipe in R and allows you to apply potentially many functions in a sequence of code. It will take in values from the LHS and apply functions on the RHS. For example, here we are doing the following:\n\n-   Select columns species, sepal length and petal length from `iris`\n-   For the newly subsetted data, replace dots with underscores and make names lower case\n-   display the first 6 rows of the data frame\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\niris %>% \n  select(Species,Sepal.Length,Petal.Length) %>%\n  rename_with(~tolower(gsub(\"\\\\.\",\"_\",.)), everything()) %>% \n  head()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  species sepal_length petal_length\n1  setosa          5.1          1.4\n2  setosa          4.9          1.4\n3  setosa          4.7          1.3\n4  setosa          4.6          1.5\n5  setosa          5.0          1.4\n6  setosa          5.4          1.7\n```\n\n\n:::\n:::\n\n\n\n\n### Assignment pipe (%\\<\\>%)\n\nTypically after applying a series of functions we want to save the result. If you are writing back to the original object a quicker step than doing:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Create data frame of normally distributed values\ndf <- data.frame(col=rnorm(100,10,1))\n# Remove values greater than 10\ndf <- df %>% filter(col<10)\n```\n:::\n\n\n\n\nis to simply use the assignment:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Create data frame of normally distributed values\ndf <- data.frame(col=rnorm(100,10,1))\n# Remove values greater than 10\ndf %<>% filter(col<10)\n```\n:::\n\n\n\n\n### Eager pipe (%!\\>%)\n\nThe eager pipe evaluates the piped input at each step, you'll notice when the code below is run with the \"lazy\" forward pipe, messages appears in a backwards order.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Set seed for reproducibility\nset.seed(42)\n# Create main function with forward pipes\nmain_fun <- function() {\n  cli::cli_progress_step(msg = \"Running main function\")\n  sample(1:100,50,replace=T) %>% \n    fun1() %>% \n    fun2() %>% \n    fun3()\n}\n# Create sub functions\nfun1 <- function(x){cli::cli_progress_step(msg = \"Function 1\");Sys.sleep(2); x*2}\nfun2 <- function(x){cli::cli_progress_step(msg = \"Function 2\");Sys.sleep(2); x+5}\nfun3 <- function(x){cli::cli_progress_step(msg = \"Function 3\");Sys.sleep(2); mean(x)}\n\n# call main function\nmain_fun()\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nℹ Running main function\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nℹ Function 3\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nℹ Function 2\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nℹ Function 1\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\n✔ Function 1 [2.1s]\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\n\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nℹ Function 2\n✔ Function 2 [4.4s]\n\nℹ Function 3\n✔ Function 3 [6.7s]\n\nℹ Running main function\n✔ Running main function [7s]\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 107.8\n```\n\n\n:::\n:::\n\n\n\n\nHowever, when applying the 'eager' pipe we see a more intuitive output which is useful for debugging as messages will appear in the order the functions are applied.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Set seed for reproducibility\nset.seed(42)\n# Create main function with eager pipes\nmain_fun <- function() {\n  cli::cli_progress_step(msg = \"Running main function\")\n  sample(1:100,50,replace=T) %!>% \n    fun1() %!>% \n    fun2() %!>% \n    fun3()\n}\n# Create sub functions\nfun1 <- function(x){cli::cli_progress_step(msg = \"Function 1\");Sys.sleep(2); x*2}\nfun2 <- function(x){cli::cli_progress_step(msg = \"Function 2\");Sys.sleep(2); x+5}\nfun3 <- function(x){cli::cli_progress_step(msg = \"Function 3\");Sys.sleep(2); mean(x)}\n\n# call main function\nmain_fun()\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nℹ Running main function\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nℹ Function 1\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\n✔ Function 1 [2.1s]\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\n\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nℹ Running main function\nℹ Function 2\n✔ Function 2 [2.2s]\n\nℹ Running main function\nℹ Function 3\n✔ Function 3 [2.1s]\n\nℹ Running main function\n✔ Running main function [7.1s]\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 107.8\n```\n\n\n:::\n:::\n\n\n\n\n### Tee pipe (%T\\>%)\n\nA regular forward pipe will update the value of the expression on the LHS from expressions on the RHS and is performed sequentially. A useful, less well-known pipe is the 'Tee Pipe'. Similar to the Tee Pipe used by your local plumber to create a junction through a T shape, the Tee Pipe takes the input on the LHS and creates a junction to bypass functions which would normally terminate. A popular example is the use of `plot` with `colSums`\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\niris %>%\n select(Sepal.Length,Sepal.Width) %>%\n plot %>%\n colSums\n```\n\n::: {.cell-output .cell-output-error}\n\n```\nError in colSums(.): 'x' must be an array of at least two dimensions\n```\n\n\n:::\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-10-1.png){width=672}\n:::\n:::\n\n\n\n\nThe above code will produce an error as the plot command does not return anything and therefore `colSums` will throw an error. Instead we can use a Tee Pipe to pass the data with `Sepal.Length` and `Sepal.Width` to both the `plot` and `colSums` argument.\n\n\n\n\n```{mermaid}\n%%| fig-width: 6.5\nflowchart LR\n  A[iris] --> B[select]\n  B --> C{T}\n  C --> D[plot]\n  C --> E[colSums]\n```\n\n::: {.cell}\n\n```{.r .cell-code}\niris %>%\n select(Sepal.Length,Sepal.Width) %T>%\n plot %>%\n colSums\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-12-1.png){width=672}\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\nSepal.Length  Sepal.Width \n       876.5        458.6 \n```\n\n\n:::\n:::\n\n\n\n\nThis is a fairly trivial example but it does have its uses. By inserting a `print` command it can be used to help with debugging or we can save an object in the middle of pipes.\n\nIt should also be noted that the use of curly brackets will give the same result.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\niris %>%\n  select(Sepal.Length,Sepal.Width) %>%\n  {plot(.)\n  colSums(.)}\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-13-1.png){width=672}\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\nSepal.Length  Sepal.Width \n       876.5        458.6 \n```\n\n\n:::\n:::\n\n\n\n\nWhat about the example below?\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\niris %>%\n  select(Sepal.Length,Sepal.Width) %T>%\n  sqrt %>%\n  colSums\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nSepal.Length  Sepal.Width \n       876.5        458.6 \n```\n\n\n:::\n:::\n\n\n\n\nYou might be wondering why this appears to not work, shouldn't this output the square root and the column sums? It turns out that it works only when one of the operations does not return a value e.g. `plot()` and `print()` are used to generate outputs and therefore the function themselves returns `NULL`.\n\n## Zeallot pipe (%\\<-%)\n\nThe [zeallot](https://cran.r-project.org/web/packages/zeallot/zeallot.pdf) package contains pipes which allow for multiple assignment. The operator allows for the user to assign from LHS to RHS or RHS to LHS. A simple example below shows how I can assign values to `x` and `y`.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nc(3,4) %->% c(x,y)\n\nc(x,y) %<-% c(3,4)\n\n\ncat(\"x = \", x, \"\\ny = \", y)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nx =  3 \ny =  4\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ndf1 <- \n  data.frame(\n    subject_id = c(\"S001-0001\", \"S001-0002\", \"S001-0003\"),\n    Trt = c(\"Pembrolizumab\", \"Pembrolizumab\", \"nivolumab\"),\n    status = c(1,1,1),\n    age = c(38,64,24),\n    time = c(10,38,83)\n    )\n\ndf2 <-\n  data.frame(\n    subject_id = c(\"S002-0001\", \"S002-0002\", \"S002-0003\"),\n    Trt = c(\"atezolizumab \", \"Pembrolizumab\", \"atezolizumab\"),\n    status = c(1,1,1),\n    age = c(24,67,12),\n    time = c(34,92,145)\n    )\n\n# Create data.tables\npurrr::map(mget(ls(pattern = '^df\\\\d+$')), as.data.table) %->%\n          c(df1, df2)\n\n# See result\nlist(df1,df2) %>% \n  lapply(\\(x) class(x))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[[1]]\n[1] \"data.table\" \"data.frame\"\n\n[[2]]\n[1] \"data.table\" \"data.frame\"\n```\n\n\n:::\n:::\n\n\n\n\n# Quiz\n\n::: {.webex-check .webex-box}\n-   **Which pipe is equivalent to** $f(g(x))$*?*\n\n\n\n\n\n\n\n\n\n<div class='webex-radiogroup' id='radio_RFFBTCVUBW'><label><input type=\"radio\" autocomplete=\"off\" name=\"radio_RFFBTCVUBW\" value=\"answer\"></input> <span>%>%</span></label><label><input type=\"radio\" autocomplete=\"off\" name=\"radio_RFFBTCVUBW\" value=\"\"></input> <span>%><%</span></label><label><input type=\"radio\" autocomplete=\"off\" name=\"radio_RFFBTCVUBW\" value=\"\"></input> <span>%!>%</span></label><label><input type=\"radio\" autocomplete=\"off\" name=\"radio_RFFBTCVUBW\" value=\"\"></input> <span>%<%</span></label></div>\n\n\n-   **Which pipe allows you to store the updated result from piping?**\n\n\n\n\n\n\n\n\n\n<div class='webex-radiogroup' id='radio_FZJHEAQGDM'><label><input type=\"radio\" autocomplete=\"off\" name=\"radio_FZJHEAQGDM\" value=\"\"></input> <span>%>%</span></label><label><input type=\"radio\" autocomplete=\"off\" name=\"radio_FZJHEAQGDM\" value=\"\"></input> <span>%><%</span></label><label><input type=\"radio\" autocomplete=\"off\" name=\"radio_FZJHEAQGDM\" value=\"answer\"></input> <span>%<>%</span></label><label><input type=\"radio\" autocomplete=\"off\" name=\"radio_FZJHEAQGDM\" value=\"\"></input> <span>%<%</span></label></div>\n\n\n-   **Which pipe can be used to assign a variable to part of, or to multiple objects?**\n\n\n\n\n\n\n\n\n\n<div class='webex-radiogroup' id='radio_JILTIKCPEX'><label><input type=\"radio\" autocomplete=\"off\" name=\"radio_JILTIKCPEX\" value=\"\"></input> <span>%>%</span></label><label><input type=\"radio\" autocomplete=\"off\" name=\"radio_JILTIKCPEX\" value=\"\"></input> <span>%><%</span></label><label><input type=\"radio\" autocomplete=\"off\" name=\"radio_JILTIKCPEX\" value=\"answer\"></input> <span>%<-%</span></label><label><input type=\"radio\" autocomplete=\"off\" name=\"radio_JILTIKCPEX\" value=\"answer\"></input> <span>%->%</span></label></div>\n\n\n-   **The magrittr pipe is considered as syntax whereas the native pipe is considered a function call** <select class='webex-select'><option value='blank'></option><option value=''>TRUE</option><option value='answer'>FALSE</option></select>\n:::\n",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}